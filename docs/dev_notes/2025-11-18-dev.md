# 2025-11-18 開發日誌（WebRTC & 動作指令日）

## 今日目標

- [x] 重新檢查 WebRTC 連線真實狀態，釐清「SCTP 問題」與「HTTP /con_notify 問題」的界線
- [x] 將 `dependency_management.md` / `webrtc_troubleshooting.md` / `docs/README.md` 等文件語氣降階，避免誤導為單一根本原因
- [x] 檢查 `TEST.sh` 內 sit/stand/balance/lie 動作的 `api_id` 與 SDK 一致性
- [x] 整理目前已知「可安全使用的 command api_id」清單
- [ ] 拿到官方 / 實機封包的完整動作列表（crouch / prone 等）——**尚未完成，需要未來實機與官方文件配合**

---

## 今日實際進度

### 1. WebRTC 連線狀態重新分析

- 重新讀過多段 `go2_driver_node` DEBUG log，區分出兩種完全不同的失敗型態：  
  - **型態 A：SCTP InitChunk timeout × 9**  
    - 屬於之前的 case，當時環境是「`aiortc 1.14.0 + STUN` + WSL2」，曾觀察到 data channel 一直卡在 `connecting`。  
  - **型態 B：HTTP `/con_notify` connect timeout**  
    - 這次你貼的最新 log：`POST http://192.168.12.1:9991/con_notify` 連線 10 秒 timeout，導致「拿不到 robot public key → signaling/connection state: closed」。  
    - SDP/ICE/DTLS 其實都已經到位，只是機器端 HTTP 服務/模式/網路有問題，這一類問題不應再全部算在 aiortc 身上。
- 也確認了一段完整成功的 session：  
  - RTP 視訊封包穩定（`RTCRtpReceiver(video) < RtpPacket(...)` 持續更新）。  
  - SCTP DataChunk + `go2_connection` log 持續收到 `rt/lf/lowstate`、`rt/utlidar/robot_pose`、`rt/utlidar/lidar_state`、`rt/multiplestate` 等。  
  - 最後是你 Ctrl+C 結束，才出現 `rcl_shutdown already called` / `asyncio CancelledError` 等 shutdown 噪音，屬於「中斷時的 cosmetic error」，不是連線本身壞掉。

### 2. 依賴管理與 WebRTC 除錯文件修正

- **`docs/dependency_management.md`**
  - 將原本「根本原因 = aiortc 1.14.0 + STUN」改成「已觀察到的高風險組合」，明講目前仍在 WSL2 / 原生 Linux / 不同固件做交叉驗證。  
  - 調整 `scipy` 說明：不再硬寫 `scipy==1.8.0`，改成「依實際需求與官方相容性建議選用」，避免與目前 `requirements.txt`（只鎖 `numpy==1.26.4`）打架。  
  - 所有 `pip install` 改為 `uv pip install`，符合 AGENTS.md 要求。

- **`docs/webrtc_troubleshooting.md`**
  - 開頭的「大多數故障就是 aiortc 版本不匹配」改為「已觀察到的常見風險之一」，不再宣稱單一 root cause。  
  - 新增一整節「情況 C：HTTP `/con_notify` 相關問題」，明確說明：  
    - 若 log 出現 `Connection to 192.168.12.1 timed out (connect timeout=10.0)`，優先應該檢查 robot 狀態 / App 佔線 / IP / WSL2 網路，而不是先懷疑 aiortc。  
    - 建議在同一機器上跑 `ping 192.168.12.1` 與 `curl -v http://192.168.12.1:9991/con_notify --max-time 5` 來區分問題層級。  
  - 移除文件中「一定會看到 SCTP 握手成功！Data channel 在 0.5 秒後開啟」這種目前程式碼還沒實作的 log 文案，改用實際可觀察的狀態（ICE completed / connectionState connected / data channel open / 有穩定 lowstate 流）。

- **`docs/README.md`**
  - 「第 2 步：確保依賴版本正確」改為「確保依賴版本合理且一致」，強調 1.9.0 是目前實測穩定的版本，而不是說「版本錯就一定掛」。  
  - Quickstart 中的安裝範例改為 `uv pip install -r requirements.txt --force-reinstall`。  
  - WebRTC 驗證一節改成用「ICE / connection state / data channel / lowstate 流」判斷健康，而不是死記某幾句字串。

- **`docs/testing_and_verification.md`**
  - 在 TEST.sh 前置條件加入說明：如果 `/con_notify` 連不到或 data channel 一直是 `connecting`，那 sit/stand/forward 等指令可能完全沒反應，要先按 webrtc_troubleshooting 流程檢查。  
  - 備註 WSL2 可能帶來網路與虛擬網卡特有問題，建議必要時在原生 Ubuntu 交叉驗證。

- **`docs/environment_setup_ubuntu.md`**
  - 在一開始補註：「本文件原先以 `fju-go2-sdk` 為專案根命名，如果你是 `elder_and_dog`，請自行對應路徑」。  
  - 將備用安裝方式中的 `pip install -r src/fju-go2-sdk/requirements.txt` 改為 `uv pip install -r ...`。

### 3. 動作指令與 api_id 調查（sit / stand / balance / move / prone）

- 從 SDK 原始碼確認（`go2_robot_sdk/go2_robot_sdk/application/utils/command_generator.py`）：  
  - `api_id=1008` 被明確註解為「Sport mode move command」，且只在 `gen_mov_command()` 中用於速度控制。  
  - `api_id=1003` 用於障礙物迴避移動（`OBSTACLE_AVOIDANCE_TOPIC`）。  
  - 結論：**1008 是「移動」，不是任何姿勢（坐/趴/蹲）。**
- 結合你之前的實機測試，現在有把握的幾個動作 api_id：
  - `1009`：`sit`（坐下，下半身坐下）。  
  - `1004`：`stand`（站起）。  
  - `1002`：`balance`（平衡站立）。  
  - `1008`：`move`（運動模式下的速度控制，不是姿勢）。  
  - `4001/4002/4003/4004/4005`：音訊 Hub 相關（TTS 那邊有實際使用）。  
- 之前嘗試把 `lie` 對應到 `api_id=1021`，實機證明「沒有動作」，而且在這個 repo 裡完全找不到任何 `ROBOT_CMD` 字典或「1021 = Wallow/Prone」的正式定義。  
  - 今日結論：  
    - 1021 在現階段只能當成「未經證實的猜測」，不能寫進正式文件當作已知動作。  
    - 文件與腳本中提到的「Wallow」只是舊版 LLM 硬翻的英文詞，**在 SDK 內沒有任何實際對應**，已全部移除或改成中性說法。
- `TEST.sh` 更新：
  - `cmd_lie()` 的說明文字改成「臥倒（Prone）」，但刻意**不宣稱 api_id 已經正確**，未來會在拿到官方動作表或實機封包後再修正。  
  - `docs/testing_and_verification.md` 也同步改為「lie（Prone）」並註記「實際動作依韌體版本為準」，避免過度描述成「完全躺平 + 打滾」這種沒證據的細節。

---

## 今日踩到的坑 & 教訓

- **文件把「一次診斷結果」寫成「唯一根本原因」**  
  - 原本 dev note 和 troubleshooting 寫得太絕對（aiortc 1.14.0 + STUN = 所有 WebRTC 問題的 root cause）。  
  - 但今天看到 `/con_notify` timeout + 完整成功的資料流，證明實際問題空間比這個大得多（機器端模式 / App 佔線 / WSL2 網路等）。  
  - 教訓：文件要誠實標註「已觀察案例」與「仍待驗證」，避免影響未來排錯方向。

- **`/con_notify` timeout 容易被誤判成「Python 端問題」**  
  - 從 log 看起來像「WebRTC 又失敗了」，但其實是 HTTP 服務沒回應。  
  - 正確做法是先用 `curl` / `ping` 驗證 robot HTTP 服務和網路，而不是一開始就懷疑 aiortc 或 STUN。

- **Ctrl+C 導致雙重 shutdown 噪音**  
  - 在成功連線時 Ctrl+C，會看到 `rcl_shutdown already called`、`asyncio CancelledError`、`Task was destroyed but it is pending!` 等錯誤。  
  - 這些是「結束流程中被中斷」的副作用，與 WebRTC 功能無關，但容易嚇到之後看到 log 的人。  
  - 教訓：未來若要整理 log 作為教學示例，要註明這些是 Ctrl+C 的噪音，避免被誤當作連線失敗。


---

## 明日 TODO（2025-11-19 預計）

1. **動作 api_id 反向工程 / 資料收集**
   - 目標：得到官方或實機驗證的動作列表（包含 crouch / prone / stretch / shake 等）。  
   - 可行路線：  
     - 用官方 App 或官方 SDK 操作各種姿勢，抓 data channel / HTTP log（在 PC 端 Wireshark 或 proxy）以取得真正的 `api_id`。  
     - 或撰寫一個「安全掃描腳本」，在保證環境安全的前提下，對有限範圍的 `api_id` 做動作試探與記錄。
   - 產出：`docs/go2_motion_commands.md`（暫定），整理「api_id ↔ 動作名稱 ↔ 實際效果」。

2. **WebRTC 健康檢查流程實作與驗證**
   - 把 `webrtc_troubleshooting.md` 內的 ping/curl 步驟做成簡單 shell helper（例如 `scripts/webrtc_health_check.sh`），方便未來一鍵檢查：  
     - `ping 192.168.12.1`  
     - `curl http://192.168.12.1:9991/con_notify --max-time 5`  
     - `python3 -c "import aiortc; print(aiortc.__version__)"`  
   - 實機在 WSL2 與原生 Ubuntu 各跑一次，對比結果填回 dev_notes。

3. **TEST.sh P0 動作的實測與文件微調**
   - 系統性跑一輪：`sit` / `stand` / `balance` / `forward` / `backward`，記錄：  
     - `sportmodestate.error_code`、`body_height`、`foot_force` 的變化；  
     - log 中任何可重複觀察的特徵。  
   - 根據實測結果微調 `docs/testing_and_verification.md` 的描述，讓說明與實際動作更接近（但避免寫死毫米級數值）。

4. **WSL2 vs 原生 Ubuntu 行為對照（若時間允許）**
   - 在非 WSL2 的 Ubuntu 機器上跑一樣的流程（連線 / TEST.sh P0），觀察：  
     - `/con_notify` 成功率與 latency；  
     - ICE / DTLS / SCTP log 是否有差異。  
   - 若差異明顯，考慮在文件中新增「WSL2 常見現象與建議」專節。

5. **檢查並修補文件殘留的過度絕對語氣**
   - 再掃一次 `docs/`（尤其是 dev_notes 舊段落），找出還在說「已完全修復」或「唯一根本原因」的敘述，統一改成：  
     - 已觀察案例、當前假說、待驗證實驗等比較科學的說法。

--- 

> 註：本日 dev note 以實際觀察與你貼出的完整 log 為主，不假設「已修好」任何尚未再次實機驗證的部分；未來若有新的實測結果，將以新增段落方式補充，而不是改寫歷史紀錄。  

